# === BEGIN USER_ALGO: TODO_ReplaceWithYourAlgoName (NO BORRAR ESTA LINEA)===
class TEST_EDU(DBAAlgorithmInterface):
    """
    Algoritmo DBA con prioridad estricta y garantías mínimas.
    Asegura mínimos por tipo de tráfico y luego reparte sobrante por prioridad.
    """
    def __init__(self):
        """Constructor simplificado"""
        pass

    def allocate_bandwidth(self, onu_requests, total_bandwidth, action=None):
        # Convertir formato de entrada si es necesario
        if isinstance(next(iter(onu_requests.values()), None), (int, float)):
            # Formato simple {onu_id: bandwidth} - convertir a formato TCONT
            converted_requests = {}
            for onu_id, bandwidth in onu_requests.items():
                # Distribuir la demanda entre TCONTs con prioridad decreciente
                converted_requests[onu_id] = {
                    'highest': bandwidth * 0.4,  # 40% a highest priority
                    'high': bandwidth * 0.3,     # 30% a high priority  
                    'medium': bandwidth * 0.2,   # 20% a medium priority
                    'low': bandwidth * 0.1,      # 10% a low priority
                    'lowest': 0                  # 0% a lowest priority
                }
            onu_requests = converted_requests
        
        # Asegura tipos
        budget_bytes = int(total_bandwidth * 1024 * 1024)  # MB to bytes
        allocations = {}

        # Demanda total por TCONT y por ONU/TCONT  
        tcont_priorities = ['highest', 'high', 'medium', 'low', 'lowest']
        demand_per_tcont = {t: 0 for t in tcont_priorities}
        
        for onu_id, tdict in onu_requests.items():
            for tcont_id, req_bytes in tdict.items():
                if tcont_id in demand_per_tcont:
                    demand_per_tcont[tcont_id] += max(0, int((req_bytes or 0) * 1024 * 1024))  # MB to bytes

        # 1) Asignar mínimos por TCONT (si hay demanda)
        assigned = 0
        min_shares = {
            'highest': 0.25,  # 25%
            'high': 0.20,     # 20%  
            'medium': 0.15,   # 15%
            'low': 0.10,      # 10%
            'lowest': 0.00    # 0%
        }
        
        for tcont_id in tcont_priorities:
            min_bytes = int(min_shares.get(tcont_id, 0.0) * budget_bytes)
            if min_bytes <= 0 or demand_per_tcont[tcont_id] <= 0:
                continue
            # repartir min_bytes proporcional a la demanda de cada ONU en ese TCONT
            total_dem_t = demand_per_tcont[tcont_id]
            for onu_id, tdict in onu_requests.items():
                req = max(0, int((tdict.get(tcont_id, 0) or 0) * 1024 * 1024))  # MB to bytes
                if req <= 0: 
                    continue
                share = int(min_bytes * (req / total_dem_t))
                if share <= 0:
                    continue
                # asignar sin exceder request ni budget
                give = min(share, req, budget_bytes - assigned)
                if give <= 0:
                    continue
                allocations.setdefault(onu_id, {})[tcont_id] = allocations.get(onu_id, {}).get(tcont_id, 0) + give
                assigned += give
                if assigned >= budget_bytes:
                    break
            if assigned >= budget_bytes:
                break

        # 2) Repartir sobrante por prioridad (de arriba hacia abajo) proporcional a demanda remanente
        if assigned < budget_bytes:
            for tcont_id in tcont_priorities:
                # demanda restante en este TCONT
                rem_total = 0
                rem_per_onu = {}
                for onu_id, tdict in onu_requests.items():
                    req = max(0, int((tdict.get(tcont_id, 0) or 0) * 1024 * 1024))  # MB to bytes
                    already = allocations.get(onu_id, {}).get(tcont_id, 0)
                    rem = max(0, req - already)
                    if rem > 0:
                        rem_per_onu[onu_id] = rem
                        rem_total += rem
                if rem_total <= 0:
                    continue

                # presupuesto disponible en esta vuelta
                leftover = budget_bytes - assigned
                if leftover <= 0:
                    break

                for onu_id, rem in rem_per_onu.items():
                    share = int(leftover * (rem / rem_total))
                    if share <= 0:
                        continue
                    give = min(share, rem, budget_bytes - assigned)
                    if give <= 0:
                        continue
                    allocations.setdefault(onu_id, {})[tcont_id] = allocations.get(onu_id, {}).get(tcont_id, 0) + give
                    assigned += give
                    if assigned >= budget_bytes:
                        break
                if assigned >= budget_bytes:
                    break

        # 3) Sanitizar y convertir de vuelta a formato simple
        final_allocations = {}
        for onu_id, tdict in allocations.items():
            total_onu_bytes = sum(tdict.values())
            # Convertir bytes a MB para compatibilidad
            final_allocations[onu_id] = total_onu_bytes / (1024 * 1024)
        
        return final_allocations
    
    def get_algorithm_name(self) -> str:
        return "TEST_EDU"
# === END USER_ALGO: TODO_ReplaceWithYourAlgoName (NO BORRAR ESTA LINEA) ===
